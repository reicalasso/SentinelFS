Bu projenin (bence) en belirgin sorunları
Aşağıdakiler repo içindeki dosyalara bakarak yaptığım hızlı statik incelemeye dayanıyor (çalıştırıp runtime davranışı görmedim). “Sorun” derken hem bug riski hem de mimari/ürünleşme problemlerini kastediyorum.

Kritik / yüksek öncelik
[“Cross‑platform” iddiası ile gerçek kodun çelişmesi]
README “Windows | Linux | macOS” diyor ama çekirdek parçalar Linux/POSIX bağımlı:
core/utils/src/PluginLoader.cpp: #include <dlfcn.h> + dlopen/dlsym → Windows’ta yok.
app/daemon/ipc/IPCHandler.cpp: AF_UNIX, SO_PEERCRED, unistd.h, sys/un.h → Windows’ta yok.
app/daemon/sentinel_daemon.cpp: setenv(...) kullanımı → POSIX.
config/systemd/... ve .sh script’ler → Linux odaklı.
CI workflow’ları (SentinelFS/.github/workflows/*.yml) sadece Ubuntu koşuyor; Windows/macOS build/test yok.
Sonuç: “Windows destekliyoruz” demek şu haliyle yanıltıcı; en azından derleme seviyesinde bile kırılma ihtimali yüksek.
[Shutdown / thread yaşam döngüsü bug’ı (muhtemel std::terminate)]
app/daemon/core/DaemonLifecycle.cpp içinde DaemonCore::stopAllThreads() var ama shutdown() içinde çağrılmıyor.
Buna rağmen sentinel_daemon.cpp içinde daemon.registerThread(std::thread(...)) ile joinable thread’ler managedThreads_ içine konuyor. DaemonCore yıkılırken std::thread joinable kalırsa program std::terminate ile düşebilir.
Dosyalar:
app/daemon/core/DaemonLifecycle.cpp: stopAllThreads() var, shutdown() içinde yok.
app/daemon/sentinel_daemon.cpp: [daemon.registerThread(std::thread(& { ... }))](cci:1://file:///c:/Users/mehme/OneDrive/Masa%C3%BCst%C3%BC/SentinelFS/SentinelFS/app/daemon/core/DaemonLifecycle.cpp:64:0-67:1) var.
Bu, sahada “bazen kapanırken crash” gibi davranışlar üretir.
[Detached thread ile olası use-after-free]
DaemonCore::reconnectToKnownPeers() içinde thread .detach() ediliyor:
app/daemon/core/DaemonLifecycle.cpp: std::thread([this, peersToConnect]() { ... }).detach();
Bu thread this->network_ / storage_ kullanıyor. Daemon kapanırsa plugin’ler shutdown edilip yok olurken bu detached thread hâlâ çalışabilir → use-after-free / race riski.
Orta öncelik (ürün kalitesi / bakım)
[Çift initialization (kopya kod) / muhtemel mantık hatası]
DaemonCore::initialize() içinde FileVersionManager iki kez kuruluyor:
app/daemon/core/DaemonLifecycle.cpp ~225–243 aralığı: aynı blok iki defa var.
Bu hem gereksiz hem de “ilk blokta sadece watchDir doluysa kur, ikinci blokta her halükarda kur” gibi çelişkili davranış yaratıyor.
[Konfigürasyon ve varsayılanlar tutarsız / bazı ayarlar etkisiz]
SentinelFS/config/sentinel.conf içinde encryption_enabled=true ama session_code yorum satırı.
sentinel_daemon.cpp ise “encryption açık + session code yoksa çık” yapıyor → default config ile daemon açılmayabilir.
sentinel.conf içinde IPC ayarları var (ipc_socket_path, ipc_socket_permissions, ipc_require_same_uid, ipc_rate_limit) ama sentinel_daemon.cpp IPC’yi oluştururken bu değerleri okuyup IPCSecurityConfig’e basmıyor; yani config yazsan da etkisiz kalma ihtimali yüksek.
IPCHandler içinde rate limit default’ları da tutarsız görünüyor:
IPCHandler.h: maxCommandsPerMinute{120}
IPCHandler.cpp default ctor: maxCommandsPerMinute = 12000; (yorumda “1200” yazıyor)
Bu tür farklar “prod’de niye böyle?” sorusu doğurur.
[Sürüm/lisans tutarsızlıkları]
README.md: MIT badge var ama metin “SPL-1.0” diyor;
LICENSE: SPL metni;
SentinelFS/gui/package.json: "license": "MIT";
SentinelFS/CMakeLists.txt: CPACK_RPM_PACKAGE_LICENSE "Apache-2.0"
Bu, release/dağıtım tarafında hukuki ve otomasyon sorunlarına yol açar.
app/cli/sentinel_cli.cpp: CLI “v0.1.0” yazıyor ama CMake/GUI “1.0.0”.
[Bağımlılık / repo yapısı dağınık]
Repo kökünde bir package.json var ama neredeyse boş; asıl GUI bağımlılıkları SentinelFS/gui/package.json içinde.
Bu “monorepo mu, subproject mi?” belirsizliği onboarding’i zorlaştırır.
IPC güvenliğiyle ilgili not (iyi + eksik)
[İyi] IPCHandler.cpp Linux’ta SO_PEERCRED ile UID/GID doğrulaması yapıyor; bu doğru yaklaşım.
[Eksik] IPCSecurityConfig içinde maxConnections ve connectionTimeoutSec var ama IPCHandler.cpp içinde bağlantı sayısı limiti ve timeout enforcement görünmüyor. Çok bağlantı açıp thread şişirme (DoS) mümkün.
Ne yapardım? (pratik öncelik sırası)
[1] DaemonCore::shutdown() içinde stopAllThreads() çağırıp thread’leri deterministik kapatmak (ve detach’leri kaldırmak).
[2] “Hedef platform ne?” kararını netleştirmek:
Windows gerçekten hedefse: IPC + plugin loader + env + script’ler için Windows/macOS uyum katmanı şart.
Linux hedefse: README/etiketler/CI buna göre düzeltilmeli.
[3] sentinel.conf varsayılanlarını, daemon’ın güvenlik şartlarıyla uyumlu hale getirmek (en azından “encryption=true ise session_code zorunlu” default’ta da sağlanmalı).
[4] Lisans & version tek kaynağa bağlanmalı (README/GUI/CMake/CPack aynı bilgiyi taşımalı).


