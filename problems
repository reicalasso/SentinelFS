Critical functional blockers (system can’t actually sync)
No inbound transport path: Transfer only ever initiates outgoing TCP connections; there’s no listener/acceptor anywhere, so peers have nothing to connect to and nothing invokes receiveDelta/receiveFile. (transfer.cpp)
Security gate blocks all traffic: SecurityManager::authenticatePeer returns false for every peer because nothing ever calls addPeerCertificate. As a result the callback in main.cpp never pushes deltas to anyone. (main.cpp around logging of “No authorized peers found”)
Received deltas never applied: Even if data arrived, there is no code that pipes Transfer::receiveDelta into DeltaEngine::apply or the filesystem. The sync flow is one-sided (produce only). (main.cpp and transfer.cpp)
SyncManager is decorative: SyncManager::processFileSync just increments counters; the async threads do nothing beyond sleeping. Selective sync, bandwidth, resume, and versioning objects are instantiated but never drive real IO. (sync_manager.cpp)
Security flaws
AES session keys unusable: encryptData/decryptData each generate a brand-new random session key; decryption can never succeed. generateSessionKey also produces a hex string but only the first 32 characters (16 bytes) are used despite AES-256 requiring 32 bytes. (security_manager.cpp)
Broken signatures: signData/verifySignature create a fresh EVP_PKEY without binding the RSA key; every call fails silently. (security_manager.cpp)
Rate-limit bookkeeping UB: inside isRateLimited, the code erases an iterator and immediately dereferences it (dataTransferred.erase(it->first)), which is undefined behaviour and will crash under load. (security_manager.cpp)
Secure transfer ignores encryption: sendSecureFile encrypts to memory, then still calls the plain sendFile, so ciphertext never leaves the process; receiveSecureFile doesn’t decrypt anything. (secure_transfer.cpp)
Certificates never materialise: createCertificate writes placeholder data using the peer IP rather than a key; addPeerCertificate is never invoked. All access-control checks therefore fail.
Networking & discovery issues
STUN lookup can’t work: discoverExternalAddress defaults to stun.l.google.com, but the code feeds that hostname straight into inet_pton, so DNS resolution always fails. (nat_traversal.cpp)
Remesh runs on random numbers: latency/bandwidth metrics are synthesised via RNG; no live measurements or integration with discovery/transfer exist, so topology decisions are meaningless. (remesh.cpp)
Discovery cleanup: Discovery::stop closes the socket and immediately reopens it without re-binding; repeated start/stop leaks descriptors and leaves threads racing. (discovery.cpp)
File-system layer concerns
Watcher stop hazard: FileWatcher::stop() calls watchThread.join() even when start() was never hit, which will terminate the process. (watcher.cpp)
No subdirectory coverage: a single inotify watch is set on the root path, so nested directories never trigger events.
Missing metadata: database insertions during events never compute hashes; FileInfo.hash stays empty, undermining delta comparisons. (main.cpp callback + db.cpp)
Delta generation is naive: updates always compare against an empty “old file” path, so every change transmits the full file. Resume/versioning hooks aren’t exercised.
Database observations
Advanced API all unused: transaction, batch, statistics, maintenance, and query helpers documented in DEAD_CODE_ANALYSIS.md are never called anywhere, so the majority of the DB module is dead weight.
Hash/conflict tracking data is never populated: although schema has columns, no caller sets them, so conflict resolution logic cannot work.
Machine-learning layer
Heuristic placeholders: MLAnalyzer, OnlineLearner, FederatedLearning, AdvancedForecasting, and NeuralNetwork all return random or hard-coded values. No models load, no training occurs, and no outputs influence sync decisions.
Online/federated modules unused: objects are constructed in main.cpp simply for logging; no code feeds them data or reads predictions.
GUI / application layer
GUI never receives live data: MainWindow expects updateFileList, updatePeerList, etc., but nothing in the CLI path publishes into it.
--gui flag stripping is brittle: manual argv shifting risks double-processing arguments and fails for repeated --gui.
Tooling & process gaps
No automated tests: test/ only holds a stub CMakeLists.txt; there’s zero unit, integration, or regression coverage.
No CI / linting: repo has no workflow or scripts to enforce standards, catch warnings, or exercise dead code.
Documentation mismatches
README advertises components that don’t exist (mesh_manager, transfer_engine, predict_anomaly.py, train_model.py) and guarantees fully working auto-remesh, secure transfer, and AI anomaly detection that aren’t implemented.
Docs claim SQLite maintenance and conflict resolution policies that never run in code.
Quality gates
Build: build.sh (CMake + make) completes successfully; there’s one unused-variable warning (ML_FORECAST_INTERVAL in main.cpp).
Tests: none available to execute.
Lint/format: not configured.
Requirements coverage
“Identify every deficiency in the application” — Done (detailed audit above spanning functional blockers, security, networking, sync, DB, ML, GUI, tooling, and documentation gaps).
Suggested next steps
Decide whether to downscope advertised features or implement the missing pieces (ingress networking, real peer auth, delta application pipeline, etc.).
Prioritise fixing security primitives before attempting real data exchange.
Add at least a thin acceptance test or integration harness so regressions surface automatically.
Update documentation to match reality or annotate features as roadmap items.